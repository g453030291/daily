# 事务

ACID

原子性：要么都成功，要么都失败

一致性：转账场景，转账前后总金额是一致的

隔离性：并发事务之间互相影响，用隔离级别来决定

持久性：事务提交后数据持久化，不会丢失

# 并发事务带来的问题

数据库上有多个事物同时执行的时候，就会有脏读、不可重复读、幻读的问题。

脏读：读到未提交的数据。

不可重复读：一个事物中，多次读取，后一次读取到其他事物修改过的数据。

幻读：一个事务中，多次读取，后一次读取到其他事物添加的数据。

脏读和幻读的区别是，脏读是修改数据，幻读是新增数据。

# SQL标准的事务隔离级别

读未提交：别的事务未提交的数据会被你看到。脏读、不可重复读、幻读。

读已提交：其他事物提交后，其他事物才能看到。不可重复读、幻读。

可重复读：在当前事务下，无论读取几次，结果的都是一样的。幻读。

串行化：所有事物串行。没有任何数据读取写入问题，但效率最低。

# MVCC

数据库的多版本并发控制

同一条记录在数据库中存在多个版本。每一个不同版本存在undolog中，叫read-view，

在可重复读的隔离级别中。一开始，就会对所有数据生成一个快照。但这时，其实并不是将所有数据复制一遍。这里记录的是，transaction id的一个数组。因为transaction id是严格有序递增的。有了这个快照以后，哪些数据可见，哪些不可见，就能根据快照中的transaction id计算出来。

# 什么是分布式事务？

分布式事务有三种场景：

- 跨数据库分布式事务
- 跨服务分布式事务
- 混合式分布式事务

# 理论支持

## CAP

C：一致性

A：可用性

P：分区容忍性

一个分布式系统中，数据的一致性、服务的可用性、服务分区容错性，三者不能同时满足。有时候甚至，牺牲一个，可能不一定能保证其它两个。

## BASE

Basicall Available：基本可用

Soft State：软状态

Eventually Consistent：最终一致性

# 分布式事务的难点在哪里？

分布式事务的参与者都分布在异步的网络中，通过网络通信来达到分布式一致性。但，网络通信一定是会出现超时、失败、异常的情况。

# 常见的分布式事务处理方案

## XA

### 二阶段提交

二阶段：预备阶段，提交/回滚阶段

①TM向各个RM询问，是否有足够的资源完成本次事务操作。如果可以，此时RM将锁定本地资源。

②如果可以都可以提交，则发送commit命令。所有RM开始执行commit，成功或失败返回给TM。如果执行失败，TM记录abrot日志，并向所有RM发送回滚命令。

#### 适用场景：

#### 缺点：

1.TM有单点故障

2.第一阶段锁定过多的资源，性能下降严重

3.第二阶段出现网络故障，会导致数据不一致

4.整个过程是串行的，不适合高并发场景

5.如果发生TM和某一个RM同时宕机的情况，新选举的TM是无法直到这个RM的提交情况

### 三阶段提交

三阶段：资源锁定，提交/回滚，超时

主要改进是在RM侧引入了超时机制，避免资源的长时间锁定。但依然无法解决脑裂的情况。

## TCC

try、confirm、cancel

针对于应用层，是一种补偿型事务，也是2PC的一个变种。

try：预留业务资源

confirm：不作任何检查，仅使用预留的资源执行业务操作

cancel：预留资源释放

①完成业务一致性检查（一致性），预留业务资源（准隔离性），即try

②try成功后，执行confirm操作，失败则一直重试。提交cancle后，也是直接释放资源，如果失败则一直重试。

### 特点：

事务的发起者和参与者都需要记录事务日志。即主事务日志，分支事务日志。依次完成数据的最终一致性。

### 缺点：

业务入侵大，原来一个接口，需要改写为三个。

### 优点：

资源层保证的事务，提到了业务层。锁的粒度更灵活，整个应用并发度更高。

## Saga

事务链（和TCC一样，是一种补偿性事务），事务成功或失败，业务是有感知的，但TCC没有。

Saga将一个分布式事务，看成一个一个的小事务串联起来的。每一个分支事务都对应一个逆向的事务操作。如果整个事务失败，那么，分支事务开始不断重试回滚。

### 缺点：

不保障隔离性。只保证原子性、一致性、持久性。

### 适用场景：

适合业务流程长的长事务场景，实现上对业务入侵较低。saga采用的是一阶段提交的模式，不会对资源长时间加锁，性能更好。

## 基于消息的分布式事务

核心思想是引入消息队列，解耦分支事务的执行。难点在于，如何将本地事务与消息绑定为一个原子性操作。即，事务成功，消息也发送成功。事务失败，消息也取消。

分为两种：一种基于RocketMQ的事务消息。不用RockerMQ的情况下，使用本地消息表。

### 基于事务消息

​		rockermq支持事务消息

### 基于本地消息

​		如果使用的mq不支持消息事务，则本地新建一张本地事务表。事务和本地事务表都在一个事务中。并且启动定时任务，扫描本地事务表。有消息未发送，则利用定时任务不断重复发送。

### 缺点：

对mq系统要求较高，对业务有一定的侵入性。要么提供事务消息状态查询接口，要么维护本地消息表。并且，原则上只接受分支事务成功，不接受事务回滚。如果失败就要一直重试。

### 适用场景：

适用对最终一致性敏感度较低的业务，例如，跨企业间的系统调用，适用场景有限。

## 最大努力通知型分布式事务

也是基于mq的一种分布式事务，但不要求mq绝对可靠。

引入定期校验机制来对一致性兜底

### 优点：

对业务入侵较低，对mq要求较低，实现简单

### 适用场景：

适合对最终一致性敏感度较低、业务链路较短的业务，比如跨平台、跨企业间的系统业务交互。

# Seata框架

seata主推AT (Automatic Transaction) 模式。

## 运行原理：

全局事务，依赖于各个分之事务。分支事务运行时，Seata Client通过解析sql，记录下执行前后数据行的快照。并记录在表中，和业务数据放在同一个事务中提交。分之事务执行完成后，立即释放锁，并向Seata Server汇报执行结果。Seata Server根据结果来判断是否commit或rollbaack。如果commit，则Seata Client清理回滚日志。如果rollback，则Seata Client根据之前记录的日志及快照进行回滚操作。回滚时，会对比数据的快照，一致则回滚，不一致则回滚失败，需人工接入处理脏数据。

## 优点：

业务零侵入

## 缺点：

只支持关系型数据库

## 注意：

1.全局默认的隔离级别是读未提交

2.对于过于复杂的sql，可能不会支持的那么好

# 总结

根据业务情况，灵活选择解决方案。

要求强一致性时，优先选择XA。

要求最终一致性时，根据具体情况，在柔性事物中灵活选择。



# 参考资料

https://mp.weixin.qq.com/s/2AL3uJ5BG2X3Y2Vxg0XqnQ

https://mp.weixin.qq.com/s/7gfmnXQRRim0OCIRC0tQ5w

https://www.junmajinlong.com

http://wuwenliang.net/